"""Phase-1 API routes for KnowEasy.

Implements endpoints used by the Phase-1 frontend ZIP (parent dashboard + student profile).

Auth
----
All endpoints require the existing session token via:
  Authorization: Bearer <token>

Role rules:
- /student/* -> role must be "student"
- /parent/*  -> role must be "parent"
Parents are read-only and may only access linked students.
"""

from __future__ import annotations

from typing import Any, Dict, Optional

from fastapi import APIRouter, Depends, Header, HTTPException

from auth_store import session_user

import phase1_store


router = APIRouter()


def _token_from_auth_header(authorization: Optional[str]) -> str:
    if not authorization:
        return ""
    parts = authorization.split()
    if len(parts) == 2 and parts[0].lower() == "bearer":
        return parts[1].strip()
    return authorization.strip()


def get_current_user(authorization: Optional[str] = Header(None)) -> Dict[str, Any]:
    token = _token_from_auth_header(authorization)
    if not token:
        raise HTTPException(status_code=401, detail="Missing token")
    u = session_user(token)
    if not u:
        raise HTTPException(status_code=401, detail="Invalid or expired token")
    return u


def require_role(role: str):
    def _dep(u: Dict[str, Any] = Depends(get_current_user)) -> Dict[str, Any]:
        if (u.get("role") or "").lower() != role:
            raise HTTPException(status_code=403, detail=f"Requires role: {role}")
        return u

    return _dep


@router.post("/student/profile")
def student_profile(payload: Dict[str, Any], u: Dict[str, Any] = Depends(require_role("student"))):
    """Upsert student profile.

    Expected payload from frontend:
    { full_name, class, board, target_exams }
    """
    full_name = payload.get("full_name")
    cls = payload.get("class")
    board = payload.get("board")
    target_exams = payload.get("target_exams")
    class_group = payload.get("class_group")

    prof = phase1_store.upsert_student_profile(
        user_id=int(u["id"]),
        full_name=full_name,
        cls=cls,
        board=board,
        target_exams=target_exams,
        class_group=class_group,
    )
    return {"ok": True, "profile": prof}


# -----------------------------------------------------------------------------
# Student → generate link code for parent (Phase‑1 persistent parent dashboard)
# -----------------------------------------------------------------------------
# The new parent linking flow calls /student/parent/link-code to obtain a
# one‑time link code that expires in 15 minutes. We keep the legacy
# /student/parent-code path for backwards compatibility.

@router.post("/student/parent/link-code")
def student_parent_link_code(u: Dict[str, Any] = Depends(require_role("student"))):
    """
    Generate a one‑time parent link code for the current student. The code
    expires after 15 minutes. The frontend should display this code to the
    parent to establish a long‑lived parent session. Returns the code and
    expiry info.
    """
    data = phase1_store.create_parent_code(student_user_id=int(u["id"]), ttl_seconds=900)
    return {"ok": True, **data}

@router.post("/student/parent-code")
def generate_parent_code_legacy(u: Dict[str, Any] = Depends(require_role("student"))):
    """Legacy endpoint for generating a parent code (alias of /student/parent/link-code)."""
    return student_parent_link_code(u)


@router.post("/parent/link")
def parent_link(payload: Dict[str, Any]):
    """
    Link a parent to a student via a one‑time code and return a persistent
    parent session token. This endpoint does not require authentication – it
    is meant for parents who are not logged in. The code must have been
    generated by /student/parent/link-code and is consumed exactly once.
    On success, returns a parent_session token (valid for 365 days) and
    expiry information. On failure, returns 400.
    """
    code = (payload.get("code") or "").strip()
    if not code:
        raise HTTPException(status_code=400, detail="Invalid or missing code")
    # Attempt to claim the code. If the code is invalid, expired or already
    # used, claim_parent_code() returns None.
    student_user_id = phase1_store.claim_parent_code(code)
    if not student_user_id:
        raise HTTPException(status_code=400, detail="Code not found or expired. Ask your child to generate a new one.")
    session_data = phase1_store.create_parent_session(student_user_id=int(student_user_id), ttl_days=365)
    return {"ok": True, **session_data}

@router.get("/parent/dashboard")
def parent_dashboard(authorization: Optional[str] = Header(None)):
    """
    Load the read‑only parent dashboard using a parent session token. The
    Authorization header must contain the session token (Bearer <token>). If
    the token is missing, invalid or expired, return 401. Otherwise return
    minimal analytics summary and placeholders. For Phase‑1 we return
    safe defaults rather than actual student data; future releases can
    surface derived analytics.
    """
    token = _token_from_auth_header(authorization)
    session = phase1_store.get_parent_session(token)
    if not session:
        raise HTTPException(status_code=401, detail="Invalid or expired parent session")
    student_id = int(session.get("student_user_id") or 0)
    # Optional: fetch analytics summary; if it fails we still return defaults.
    summary: Dict[str, Any] = {}
    try:
        summary = phase1_store.analytics_summary(parent_user_id=0, student_user_id=student_id)
    except Exception:
        summary = {}
    # Build minimal safe default response. We intentionally avoid exposing
    # student details or sensitive information. The structure matches the
    # frontend expectations but can be extended later.
    response: Dict[str, Any] = {
        "ok": True,
        "student": {"label": "Student"},
        "today": {"minutes": 0, "last_active": None},
        "week": {"minutes": 0, "active_days": 0, "subjects": []},
        "progress": {"in_progress": [], "completed": 0, "needs_revision": []},
        "note": "Weekly summary will appear here.",
    }
    # Optionally populate week metrics from summary if available
    if summary:
        try:
            response["week"]["minutes"] = int(summary.get("time_spent_minutes_7d", 0))
            response["week"]["active_days"] = int(summary.get("active_days_7d", 0))
        except Exception:
            pass
    return response


@router.get("/parent/students")
def parent_students(u: Dict[str, Any] = Depends(require_role("parent"))):
    students = phase1_store.list_parent_students(parent_user_id=int(u["id"]))
    return {"ok": True, "students": students}


@router.get("/parent/analytics/summary")
def parent_analytics_summary(student_user_id: int, u: Dict[str, Any] = Depends(require_role("parent"))):
    if not phase1_store.is_parent_linked(parent_user_id=int(u["id"]), student_user_id=int(student_user_id)):
        raise HTTPException(status_code=403, detail="Not linked to this student")
    summary = phase1_store.analytics_summary(parent_user_id=int(u["id"]), student_user_id=int(student_user_id))
    return {"ok": True, "summary": summary}


@router.post("/events/track")
def events_track(payload: Dict[str, Any], u: Dict[str, Any] = Depends(get_current_user)):
    """
    Lightweight event tracking. We validate the payload and attempt to store
    it in either Postgres or Redis. Under no circumstances does this endpoint
    raise a 500 – if any unexpected error occurs the API responds with
    {ok:true} to avoid frontend disruption. Only invalid event_type values
    return a 400.
    """
    try:
        event_type = payload.get("event_type")
        meta = payload.get("meta")
        duration_sec = payload.get("duration_sec")
        value_num = payload.get("value_num")
        phase1_store.track_event(
            user_id=int(u["id"]),
            event_type=event_type,
            meta=meta,
            duration_sec=duration_sec,
            value_num=value_num,
        )
        return {"ok": True}
    except ValueError as e:
        # Invalid event_type or payload
        raise HTTPException(status_code=400, detail=str(e))
    except Exception:
        # Swallow all other errors (e.g. DB unavailable) and return ok
        return {"ok": True}
